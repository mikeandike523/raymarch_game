<!doctype html>
<html>
   <body style="width:100%;height:100%;border:none;padding:none">
      <style>
        canvas {
    position: absolute;
    top:0;
    bottom: 0;
    left: 0;
    right: 0;
    margin:auto;
}
}
      </style>
      <canvas width = "600" height = "600" id = "my_Canvas"></canvas>
        <script src="scene.js"></script>
      <script>
         //todo: make scene sdf and shading function able to be entered via a textbox
         //todo: find out what idea you really want to do
         
         /*============= Creating a canvas =================*/
         var canvas = document.getElementById('my_Canvas');
         gl = canvas.getContext('experimental-webgl');
         canvas.onclick = function() {
  canvas.requestPointerLock();
}

var cP=[0,0,0];
         var cE=[Math.PI/2,0];
function canvasLoop(e) {
  var movementX = e.movementX ||
      e.mozMovementX          ||
      e.webkitMovementX       ||
      0;

  var movementY = e.movementY ||
      e.mozMovementY      ||
      e.webkitMovementY   ||
      0;

      cE[0]-=movementX*Math.PI/60;
      if(Math.abs(cE[1]-movementY*Math.PI/60)<Math.PI/2*1.0)
      cE[1]-=movementY*Math.PI/60;


}
function lockChangeAlert() {
  if(document.pointerLockElement === canvas) {
    console.log('The pointer lock status is now locked');
    document.addEventListener("mousemove", canvasLoop, false);
  } else {
    console.log('The pointer lock status is now unlocked');  
    document.removeEventListener("mousemove", canvasLoop, false);
  }
}
document.addEventListener('pointerlockchange', lockChangeAlert, false);
         var up = false,
    right = false,
    down = false,
    left = false;
    var turnLeft=false;
    var turnRight=false;
    var lookUp=false;
    var lookDown=false;
    var rising=false;
    var falling=false;
    var towards=false;

         /*============ Defining and storing the geometry =========*/

         var vertices = [
            -1,-1,-1, 1,-1,-1, 1, 1,-1, -1, 1,-1,
           
         ];

         var indices = [
            0,1,2, 0,2,3, 4,5,6, 4,6,7,
   
         ];

         // Create and store data into vertex buffer
         var vertex_buffer = gl.createBuffer ();
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

         // Create and store data into index buffer
         var index_buffer = gl.createBuffer ();
         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
         gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

         /*=================== Shaders =========================*/

         var vertCode = `attribute vec3 position;
            uniform mat4 Pmatrix;
            uniform mat4 Vmatrix;
            uniform mat4 Mmatrix;
         
            varying vec2 uv;
            void main(void) { 
               gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);
               uv=position.xy;
            }`;

         var fragCode = `precision mediump float;
            varying vec3 vColor;
            varying vec2 uv;
            const float MARCH_DRAWDIST=100.;
            const int MAX_ITERS=50;
            const float epsilon=0.005;
            const float normal_epsilon=0.000005;
            uniform vec3 cameraPos;
            uniform mat3 cameraEuler;
            uniform mat3 cameraEuler2;
            
            float sceneDistance(vec3 p){
            `
               +sceneDistanceScript+
             `  
            }
            
            float march(vec3 ro, vec3 rd){
               vec3 p=ro;
               float lastDist=sceneDistance(ro);
               for(int i=0;i<MAX_ITERS;i++){
                  if(length(p-ro)>MARCH_DRAWDIST)
                     break;
                  p=ro+rd*lastDist;
                  float currentDist=sceneDistance(p);
                  if(currentDist<epsilon){
                     return length(p-ro);
                  }
                  lastDist+=currentDist;
               }
               return -1.;
            }
            vec3 getColor(vec3 ro, vec3 rd, vec3 pt, vec3 n){
               `+shadingScript+
               `
            }

            // note, camera movement will require coordinate transformations
            // this algorithm is from centered camera
            vec3 getNormal(vec3 ro,vec3 rd){
               float dist1=march(ro,rd);

               //to the right on screen
               vec3 rd2=vec3(rd.x+normal_epsilon,rd.y,rd.z);
               float dist2=march(ro,rd2);

               //upward on screen
               vec3 rd3=vec3(rd.x,rd.y+normal_epsilon,rd.z);
               float dist3=march(ro,rd3);
               
               if(dist1<0.0 || dist2<0.0 || dist3<0.0){
                  //in case any rays miss or fall through, set normal to 0
                  //todo, determine experimentally if this is the best approach
                  return vec3(1.0,0.0,0.0);
               }
               
               //all rays did not fall through
               vec3 pt1=ro+rd*dist1;
               vec3 pt2=ro+rd2*dist2;
               vec3 pt3=ro+rd3*dist3;

               vec3 d1=pt2-pt1;
               vec3 d2=pt3-pt1;
               return -1.*normalize(cross(d1,d2));

            }
            void main(void) {
               vec3 ro=cameraPos;
               vec3 rd= cameraEuler*cameraEuler2*normalize(vec3(uv.x,uv.y,1.));
               float dist=march(ro,rd);
               vec3 pt=rd+dist*rd;
               if (dist<0.0)
               {
                  discard;
               }
               else
               {
                  vec3 n=getNormal(ro,rd);
                  gl_FragColor=vec4(getColor(ro,rd,pt,n),1.0);
               }
            }`;

         var vertShader = gl.createShader(gl.VERTEX_SHADER);
         gl.shaderSource(vertShader, vertCode);
         gl.compileShader(vertShader);

         var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
         gl.shaderSource(fragShader, fragCode);
         gl.compileShader(fragShader);

         var shaderProgram = gl.createProgram();
         gl.attachShader(shaderProgram, vertShader);
         gl.attachShader(shaderProgram, fragShader);
         gl.linkProgram(shaderProgram);

         var compiled = gl.getShaderParameter(vertShader, gl.COMPILE_STATUS);
         console.log('Shader compiled successfully: ' + compiled);
         var compilationLog = gl.getShaderInfoLog(vertShader);
         console.log('Shader compiler log: ' + compilationLog);

         var compiled = gl.getShaderParameter(fragShader, gl.COMPILE_STATUS);
         console.log('Shader compiled successfully: ' + compiled);
         var compilationLog = gl.getShaderInfoLog(fragShader);
         console.log('Shader compiler log: ' + compilationLog);

         /* ====== Associating attributes to vertex shader =====*/
         var Pmatrix = gl.getUniformLocation(shaderProgram, "Pmatrix");
         var Vmatrix = gl.getUniformLocation(shaderProgram, "Vmatrix");
         var Mmatrix = gl.getUniformLocation(shaderProgram, "Mmatrix");

         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
         var position = gl.getAttribLocation(shaderProgram, "position");
         gl.vertexAttribPointer(position, 3, gl.FLOAT, false,0,0) ;

         // Position
         gl.enableVertexAttribArray(position);
   

    
         gl.useProgram(shaderProgram);


         var cameraPos=gl.getUniformLocation(shaderProgram,'cameraPos');
         var cameraEuler=gl.getUniformLocation(shaderProgram,'cameraEuler');
         var cameraEuler2=gl.getUniformLocation(shaderProgram,'cameraEuler2');
        
         /*==================== MATRIX =====================*/


         var proj_matrix =[1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];

         var mov_matrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
         var view_matrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];

       

         /*==================== Rotation ====================*/

         

         /*================= Drawing ===========================*/
         var time_old = 0;

         
         gl.clearColor(0,0,0,1);
         var animate = function(time) {

            var dt = time-time_old;

            time_old = time;
            speed=0.1
            if(up){
               cP[0]+=Math.cos(cE[0])*speed;
               if(towards)
               cP[1]+=Math.sin(cE[1])*speed;
               cP[2]+=Math.sin(cE[0])*speed;
            }
            if(down){
               cP[0]-=Math.cos(cE[0])*speed;
               if(towards)
               cP[1]-=Math.sin(cE[1])*speed;
               cP[2]-=Math.sin(cE[0])*speed;
            }

            if(left){
               cP[0]+=-Math.sin(cE[0])*speed;
               cP[2]+=Math.cos(cE[0])*speed;
            }

            if(right){
               cP[0]-=-Math.sin(cE[0])*speed;
               cP[2]-=Math.cos(cE[0])*speed;
            }

            if(turnRight){
               cE[0]-=Math.PI/20;
            }
            if(turnLeft){
               cE[0]+=Math.PI/20;
            }
            if(rising){

                  cP[1]+=speed;
            }
            if(falling){

               cP[1]-=speed;
            }

            
            
              
                
            gl.viewport(0.0, 0.0, canvas.width, canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.uniformMatrix4fv(Pmatrix, false, proj_matrix);
            gl.uniformMatrix4fv(Vmatrix, false, view_matrix);
            gl.uniformMatrix4fv(Mmatrix, false, mov_matrix);
            gl.uniform3fv(cameraPos,cP);
            //for now start with just xz rotation
            var a=cE[0]-Math.PI/2;
            var b=cE[1];
            gl.uniformMatrix3fv(cameraEuler,false,[Math.cos(a),0,Math.sin(a),0,1,0,-Math.sin(a),0,Math.cos(a)]);
            gl.uniformMatrix3fv(cameraEuler2,false,[1,0,0,0,Math.cos(b),-Math.sin(b),0,Math.sin(b),Math.cos(b)]);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

            window.requestAnimationFrame(animate);
         }
         animate(0);


       

document.addEventListener('keydown',press)
function press(e){
   `
  if (e.keyCode === 38 /* up */ || e.keyCode === 87 /* w */ ){
    up = true
  }
  if (e.keyCode === 39 /* right */ || e.keyCode === 68 /* d */){
    right = true
  }
  if (e.keyCode === 40 /* down */ || e.keyCode === 83 /* s */){
    down = true
  }
  if (e.keyCode === 37 /* left */ || e.keyCode === 65 /* a */ ){
    left = true
  }
  `
  if ( e.keyCode === 87 /* w */ ){
    up = true
  }
  if (e.keyCode === 68 /* d */){
    right = true
  }
  if ( e.keyCode === 83 /* s */){
    down = true
  }
  if ( e.keyCode === 65 /* a */ ){
    left = true
  }
  if ( e.keyCode === 39 ){
    turnRight=true
  }
  if ( e.keyCode === 37 ){
    turnLeft=true
  }

  if ( e.keyCode === 38 ){
    lookUp=true
  }
  if ( e.keyCode === 40 ){
    lookDown=true
  }

  if ( e.keyCode === 81 ){
    rising=true
  }
  if ( e.keyCode === 69 ){
    falling=true
  }
  if ( e.keyCode === 32 ){
   towards=true
  } 
}
document.addEventListener('keyup',release)
function release(e){
   `
  if (e.keyCode === 38 /* up */ || e.keyCode === 87 /* w */ ){
    up = false
  }
  if (e.keyCode === 39 /* right */ || e.keyCode === 68 /* d */){
    right = false
  }
  if (e.keyCode === 40 /* down */ || e.keyCode === 83 /* s */){
    down = false
  }
  if (e.keyCode === 37 /* left */ || e.keyCode === 65 /* a */ ){
    left = false
  }
  `
  if ( e.keyCode === 87 /* w */ ){
    up = false;
   
   }
  if (e.keyCode === 68 /* d */){
    right = false
  }
  if ( e.keyCode === 83 /* s */){
    down = false
  }
  if ( e.keyCode === 65 /* a */ ){
    left = false
  }
  if ( e.keyCode === 39 ){
    turnRight=false
  }
  if ( e.keyCode === 37 ){
    turnLeft=false
  }
  if ( e.keyCode === 38 ){
    lookUp=false
  }
  if ( e.keyCode === 40 ){
    lookDown=false
  }
  if ( e.keyCode === 81 ){
    rising=false
  }
  if ( e.keyCode === 69 ){
    falling=false
  }
  if ( e.keyCode === 32 ){
   towards=false
  } 
}





      </script>
   </body>
</html>